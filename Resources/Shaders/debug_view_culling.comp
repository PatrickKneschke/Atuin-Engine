#version 460


//input
layout (local_size_x = 256) in;

// depth pyramid
layout(set = 0, binding = 0) uniform sampler2D depthPyramid;

// object data
struct ObjectData {
	mat4 transform;
	vec4 sphereBounds;
}; 
layout(std140, set = 0, binding = 1) readonly buffer ObjectBuffer {
	ObjectData objects[];
} objectBuffer;

// instance data -> initial batch and object indices of all instances
struct InstanceData {
	uint batchIdx;
	uint objectIdx;
};
layout(set = 0, binding = 2) readonly buffer InstanceBuffer {   
	InstanceData instances[];
} instanceDataBuffer;

//draw indirect data -> fill instance count
struct IndirectData {	
	uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
	uint batchID;
	uint objectID;
};
layout(set = 0, binding = 3) buffer IndirectBuffer {
	IndirectData indirects[];
} drawIndirectBuffer;

// instance data -> final instance object indices after culling
layout(set = 0, binding = 4) writeonly buffer InstanceBuffer2 {
	uint objectIndices[];
} finalInstanceBuffer;

// culling data push constants
struct ViewCullData {
	mat4 view; // camera view matrix (right handed, posive z towards viewer)
	
	float P00, P11, zNear, zFar; // symmetric projection parameters
	float frustum[4]; // data for left/right/top/bottom frustum planes
	float pyramidWidth, pyramidHeight; // depth pyramid size in texels

	uint drawCount;
	uint enableDistCull;
	uint enableOcclusionCull;

};
layout(push_constant) uniform  Constants {
   ViewCullData cullData;
};



// debug
struct DebugData {	
	vec4 aabb;
	float depth;
	float sampledDepth;
	float level;
	uint culled;
};
layout(std430, set = 0, binding = 5) writeonly buffer DebugBuffer {
	DebugData debug[];
} debugBuffer;



// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
bool ProjectSphere( vec3 center, float radius, float zNear, float P00, float P11, out vec4 aabb) {

	if ( center.z + radius >= zNear)
	{
		return false;
	}

	// vec2 cx = -center.xz;
	// vec2 vx = vec2( sqrt( dot( cx, cx) - radius * radius), radius);
	// vec2 minx = mat2( vx.x,  vx.y, -vx.y, vx.x) * cx;
	// vec2 maxx = mat2( vx.x, -vx.y,  vx.y, vx.x) * cx;

	// vec2 cy = -center.yz;
	// vec2 vy = vec2( sqrt( dot( cy, cy) - radius * radius), radius);
	// vec2 miny = mat2( vy.x,  vy.y, -vy.y, vy.x) * cy;
	// vec2 maxy = mat2( vy.x, -vy.y,  vy.y, vy.x) * cy;

	// aabb = vec4( minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
	// // aabb = 0.5 * aabb.xwzy + 0.5; // clip space -> uv space
	// aabb = aabb.xwzy * vec4( 0.5f, -0.5f, 0.5f, -0.5f) + vec4( 0.5f); // clip space -> uv space


	vec2 cxz = center.xz;
	float dx2 = dot(cxz, cxz);
	float lx = sqrt( dx2 - radius*radius);
	float minX = P00 * (lx * cxz.x + radius * cxz.y) / (-radius * cxz.x + lx * cxz.y);
	float maxX = P00 * (lx * cxz.x - radius * cxz.y) / ( radius * cxz.x + lx * cxz.y);
	
	vec2 cyz = center.yz;
	float dy2 = dot(cyz, cyz);
	float ly = sqrt( dy2 - radius*radius);
	float minY = P11 * (ly * cyz.x - radius * cyz.y) / ( radius * cyz.x + ly * cyz.y);
	float maxY = P11 * (ly * cyz.x + radius * cyz.y) / (-radius * cyz.x + ly * cyz.y);

	aabb = -0.5 * vec4(minX, minY, maxX, maxY) + 0.5;
	// aabb.yw = aabb.wy;

	return true;
}


bool IsVisible( uint objectIndex) {

	vec4 sphereBounds = objectBuffer.objects[objectIndex].sphereBounds;

	vec3 center = sphereBounds.xyz;
	center = (cullData.view * vec4(center, 1.f)).xyz;
	float radius = sphereBounds.w;
	
	bool visible = true;



	// the left/top/right/bottom plane culling utilizes frustum symmetry to cull against two planes at the same time
	visible = visible  &&  center.z * cullData.frustum[1] - abs(center.x) * cullData.frustum[0] > -radius;
	visible = visible  &&  center.z * cullData.frustum[3] + abs(center.y) * cullData.frustum[2] > -radius;

	// the near/far plane culling uses camera space Z directly
	if ( cullData.enableDistCull != 0)
	{
		visible = visible  &&  center.z - cullData.zNear < radius  &&  center.z - cullData.zFar > -radius;
	}
	
	if ( visible && cullData.enableOcclusionCull != 0)
	{
		//flip Y because we access depth texture that way
		// center.y *= -1;
	
		vec4 aabb;
		if ( ProjectSphere(center, radius, cullData.zNear, cullData.P00, cullData.P11, aabb))
		{
			float width = (aabb.z - aabb.x) * cullData.pyramidWidth;
			float height = (aabb.w - aabb.y) * cullData.pyramidHeight;
			float level = floor( log2( max(width, height)));

			// Sampler is set up to do max reduction, so this computes the maximum depth of a 2x2 texel quad
			float depth = textureLod( depthPyramid, (aabb.xy + aabb.zw) * 0.5, level).x;
			// float sphereDepth = cullData.zNear / (center.z + radius);
			// float sphereDepth = 0.5 * (cullData.zNear + cullData.zFar) / (cullData.zFar - cullData.zNear) - (cullData.zNear * cullData.zFar) / (cullData.zFar - cullData.zNear) / (center.z + radius) + 0.5;
			float sphereDepth = (cullData.zFar - 2 * cullData.zNear * cullData.zFar / (center.z + radius)) / (cullData.zFar - 2 * cullData.zNear);


			// float depthZ = 2 * cullData.zNear * cullData.zFar / ( cullData.zFar - depth*( cullData.zFar - 2 * cullData.zNear));
			

			visible = visible  &&  sphereDepth < depth;

			debugBuffer.debug[ objectIndex].aabb = aabb;
			debugBuffer.debug[ objectIndex].depth = sphereDepth;
			debugBuffer.debug[ objectIndex].sampledDepth = depth;
			debugBuffer.debug[ objectIndex].level = level;
			if ( !visible)
				debugBuffer.debug[ objectIndex].culled = 1;
		}
	}
	


	// // the left/top/right/bottom plane culling utilizes frustum symmetry to cull against two planes at the same time
	// visible = visible && center.z * cullData.frustum[1] - abs(center.x) * cullData.frustum[0] > -radius;
	// visible = visible && center.z * cullData.frustum[3] - abs(center.y) * cullData.frustum[2] > -radius;


	// // the near/far plane culling uses camera space Z directly
	// if ( cullData.enableDistCull != 0)
	// {
	// 	visible = visible  &&  center.z + radius > cullData.zNear  &&  center.z - radius < cullData.zFar;
	// }

	// if ( visible && cullData.enableOcclusionCull != 0)
	// {
	// 	//flip Y because we access depth texture that way
	// 	center.y *= -1;
	
	// 	vec4 aabb;
	// 	if ( ProjectSphere(center, radius, cullData.zNear, cullData.P00, cullData.P11, aabb))
	// 	{
	// 		float width = (aabb.z - aabb.x) * cullData.pyramidWidth;
	// 		float height = (aabb.w - aabb.y) * cullData.pyramidHeight;
	// 		float level = floor( log2( max(width, height)));

	// 		// Sampler is set up to do min reduction, so this computes the minimum depth of a 2x2 texel quad
	// 		float depth = textureLod( depthPyramid, (aabb.xy + aabb.zw) * 0.5, level).x;
	// 		float sphereDepth = cullData.zNear / (center.z - radius);

	// 		visible = visible && sphereDepth >= depth;
	// 	}
	// }

	return visible;
}


void main() {

	uint gID = gl_GlobalInvocationID.x;
	if ( gID < cullData.drawCount)
	{
		uint objectIdx = instanceDataBuffer.instances[gID].objectIdx;


			debugBuffer.debug[ objectIdx].aabb = vec4(0.f);
			debugBuffer.debug[ objectIdx].depth = 0.f;
			debugBuffer.debug[ objectIdx].sampledDepth = 0.f;
			debugBuffer.debug[ objectIdx].level = 0.f;
			debugBuffer.debug[ objectIdx].culled = 0;
		

		if ( IsVisible( objectIdx))
		{
			uint batchIdx = instanceDataBuffer.instances[gID].batchIdx;
			uint countIndex = atomicAdd( drawIndirectBuffer.indirects[batchIdx].instanceCount, 1);

			uint instanceIndex = drawIndirectBuffer.indirects[batchIdx].firstInstance + countIndex;

			finalInstanceBuffer.objectIndices[instanceIndex] = objectIdx;
		}
	}
}