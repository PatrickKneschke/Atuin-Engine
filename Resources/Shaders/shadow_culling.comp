#version 460


//input
layout (local_size_x = 256) in;

// object data
struct ObjectData {
	mat4 transform;
	vec4 sphereBounds;
}; 
layout(std140, set = 0, binding = 0) readonly buffer ObjectBuffer {
	ObjectData objects[];
} objectBuffer;

// instance data -> initial batch and object indices of all instances
struct InstanceData {
	uint batchIdx;
	uint objectIdx;
};
layout(set = 0, binding = 1) readonly buffer InstanceBuffer {   
	InstanceData instances[];
} instanceDataBuffer;

//draw indirect data -> fill instance count
struct IndirectData {	
	uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
	uint batchID;
	uint objectID;
};
layout(set = 0, binding = 2) buffer IndirectBuffer {
	IndirectData indirects[];
} drawIndirectBuffer;

// instance data -> final instance object indices after culling
layout(set = 0, binding = 3) writeonly buffer InstanceBuffer2 {
	uint objectIndices[];
} finalInstanceBuffer;

// view matrices for each shadow cascade including aabb extent in view[3][3]
layout(set = 0, binding = 4) readonly buffer CascadeViews {
	mat4 view[];
} cascades;

// culling data push constants
struct ShadowCullData {
	uint drawCount;
	uint cascadeCount;
};
layout(push_constant) uniform Constants {
   ShadowCullData cullData;
};


bool IsVisible( uint objectIndex) {

	vec4 sphereBounds = objectBuffer.objects[ objectIndex].sphereBounds;

	vec3 center = sphereBounds.xyz;
	float radius = sphereBounds.w;

	for (int i = 0; i < cullData.cascadeCount; i++)
	{
		vec4 c = cascades.view[i] * vec4(center, 1.0);
		// c.w is the extent of the aabb
		bool visible = (c.x + radius > -c.w  &&  c.x - radius < c.w)
					&& (c.y + radius > -c.w  &&  c.y - radius < c.w)
					&& (c.z - radius < 0     &&  c.z + radius > -4*c.w);

		if (visible)
		{
			return true;
		}
	}

	return false;
}


void main() {

	uint gID = gl_GlobalInvocationID.x;
	if ( gID < cullData.drawCount)
	{
		uint objectIdx = instanceDataBuffer.instances[gID].objectIdx;

		if ( IsVisible( objectIdx))
		{
			uint batchIdx = instanceDataBuffer.instances[gID].batchIdx;
			uint countIndex = atomicAdd( drawIndirectBuffer.indirects[batchIdx].instanceCount, 1);

			uint instanceIndex = drawIndirectBuffer.indirects[batchIdx].firstInstance + countIndex;

			finalInstanceBuffer.objectIndices[instanceIndex] = objectIdx;
		}
	}
}